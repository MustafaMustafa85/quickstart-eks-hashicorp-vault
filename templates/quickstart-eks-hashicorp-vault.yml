AWSTemplateFormatVersion: "2010-09-09"
Description: "Deploys the Hashicorp Vault helm chart into a Kubernetes cluster (qp-1qmcrhdml)"
Metadata:
  QSLint:
    Exclusions: [W9002, W9003, W9004, W9006]
Parameters:
  ClusterName:
    Type: String
    Description: Amazon EKS Cluster
  VaultVersion:
    Type: String
    Default: "1.4.3"
    AllowedValues: 
    - "1.4.3"
  KubernetesNameSpace:
    Default: default
    Type: String
  OIDCProvider:
    Type: String
    Description: Amazon EKS cluster OIDC provider. (Without the protocol e.g. oidc.eks.us-east-1.amazonaws.com/id/SADFASFFASFXCCVXCVSDFSDF)
  Nodes:
    Type: Number
    Default: "5"
    AllowedValues:
      - "5"
      - "7"
      - "9"
  BootStrapScriptS3URI:
    Type: String
    Default: s3://aws-quickstart/quickstart-eks-hashicorp-vault/scripts/bootstrap.sh
  ValuesYamlURI:
    Type: String 
    Default :  s3://aws-quickstart/quickstart-eks-hashicorp-vault/scripts/values.yaml
#Mappings:
#  VaultVersions:
#    Vault1.4: https://github.com/hashicorp/vault-helm/archive/v0.5.0.tar.gz
Conditions:
  # TODO: Create Node Group condition 
  CreateCluster: !Equals [ !Ref ClusterName, "" ]
Resources:
  #EKSNodeGroup:
  # TODO: Nodegroup create with Labels only for Vault other stuff is dissallowed
  #  Type: AWSQS::EKS::ClusterNodeGroup 
  #  Condition: CreateCluster
  #    3 Node minimum (Expose)
  #    EKS Cluster Node size - m5.large (Expose)
  #    Private EKS Cluster 3 AZ
  #    AccessCidr - Disabled or Private (Expose)
  #    CloudWatch - Logging by Default (Expose)
  #    Additional Expose AdminUserArn (Expose)
  #    Additional Expose AdminRoleArn (Expose)
  #    AutoScaler enabled for the EKS Cluster
  #    ProvisionBastionHost: disabled (Expose)
  PsuedoRandom:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: DoNotUse
  VaultRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub "VaultIAMRole-${PsuedoRandom.GroupId}"
      AssumeRolePolicyDocument: !Sub
      - |
        {
          "Version": "2012-10-17",
          "Statement": [
            {
              "Effect": "Allow",
              "Principal": {
                "Federated": "arn:aws:iam::${AWS::AccountId}:oidc-provider/${OIDCProvider}"
              },
              "Action": "sts:AssumeRoleWithWebIdentity",
              "Condition": {
                "StringEquals": {
                  "${OIDCProvider}:sub": "system:serviceaccount:${NameSpace}:${ResourceName}"
                }
              }
            }
          ]
        }
      - NameSpace: !Ref KubernetesNameSpace
        ResourceName: booter-vault
      Path: "/"
      Policies:
      - PolicyName: root
        PolicyDocument:
          Version: '2012-10-17'
          Statement:
          - Effect: Allow
            Action:
            - logs:CreateLogStream
            - logs:DescribeLogStreams
            Resource:
            - !Sub "arn:${AWS::Partition}:logs:${AWS::Region}:${AWS::AccountId}:log-group:Vault-Audit-Logs-${AWS::StackName}"
          - Effect: Allow
            Action:
            - logs:PutLogEvents
            Resource:
            - !Sub "arn:${AWS::Partition}:logs:${AWS::Region}:${AWS::AccountId}:log-group:Vault-Audit-Logs-${AWS::StackName}:log-stream:*"
          - Effect: Allow
            Action:
            - ec2:DescribeInstances
            Resource: "*"
          - Effect: Allow
            Action: 
            - s3:*
            Resource:
            - "*"
          - Effect: Allow
            Action:
            - secretsmanager:UpdateSecretVersionStage
            - secretsmanager:UpdateSecret
            - secretsmanager:PutSecretValue
            - secretsmanager:GetSecretValue
            Resource:
            - !Sub "arn:${AWS::Partition}:secretsmanager:${AWS::Region}:${AWS::AccountId}:secret:VaultSecret-${PsuedoRandom.GroupId}*"
          - Effect: Allow
            Action:
              - iam:GetRole
            Resource: !Sub "arn:${AWS::Partition}:secretsmanager:${AWS::Region}:${AWS::AccountId}:role/VaultIAMRole-${PsuedoRandom.GroupId}"
  VaultKmsKey:
    Type: AWS::KMS::Key
    DependsOn: VaultRole
    Properties:
      Description: "Vault Seal/Unseal key"
      KeyPolicy:
        Version: '2012-10-17'
        Id: key-default-1
        Statement:
        - Sid: Enable IAM User Permissions
          Effect: Allow
          Principal:
            AWS: !Sub "arn:aws:iam::${AWS::AccountId}:root"
          Action: kms:*
          Resource: '*'
        - Sid: Allow administration of the key
          Effect: Allow
          Principal:
            AWS: !Sub "arn:aws:iam::${AWS::AccountId}:role/VaultIAMRole-${PsuedoRandom.GroupId}"
          Action:
          - kms:Create*
          - kms:Describe*
          - kms:Enable*
          - kms:List*
          - kms:Put*
          - kms:Update*
          - kms:Revoke*
          - kms:Disable*
          - kms:Get*
          - kms:Delete*
          - kms:ScheduleKeyDeletion
          - kms:CancelKeyDeletion
          Resource: '*'
        - Sid: Allow use of the key
          Effect: Allow
          Principal:
            # If the Lambda Functions need to use this key we must add their execution roles here as principles
            AWS: !Sub "arn:aws:iam::${AWS::AccountId}:role/VaultIAMRole-${PsuedoRandom.GroupId}"
          Action:
          - kms:DescribeKey
          - kms:Encrypt
          - kms:Decrypt
          - kms:ReEncrypt*
          - kms:GenerateDataKey
          - kms:GenerateDataKeyWithoutPlaintext
          Resource: '*'
  VaultSecret:
    Type: AWS::SecretsManager::Secret
    Properties:
      Name: "VaultSecret-Abc"
      Description: "Vault Root/Recovery key"
      KmsKeyId: !Ref VaultKmsKey 
      SecretString: "empty"
  HashicorpVaultHelmChart:
    Type: "AWSQS::Kubernetes::Helm"
    Properties:
      ClusterID: !Ref ClusterName
      Repository: https://helm.releases.hashicorp.com
      Namespace: !Ref KubernetesNameSpace
      Name: vault
      Chart: hashicorp/vault
      # TODO: Add kubernetes service role
      ValueYaml: !Sub
      - |
        # ${SomeValue}
        ui:
          enabled: true
        server:
          image:
            repository: "vault"
            tag: ${VaultVersion}
          logLevel: "debug"
          serviceAccount:
            annotations: !Sub |
              eks.amazonaws.com/role-arn: "arn:aws:iam::${AWS::AccountId}:role/VaultIAMRole-${PsuedoRandom.GroupId}"
          extraEnvironmentVars: # for 1.4.3 no auto assigned name
            AWS_ROLE_SESSION_NAME: some_name
          ha:
            enabled: true
            nodes: ${Nodes}
            raft:
              enabled: true
              setNodeId: true
              config: |
                ui = true

                listener "tcp" {
                  tls_disable = 1
                  address = "[::]:8200"
                  cluster_address = "[::]:8201"
                }

                storage "raft" {
                  path    = "/vault/data"
                }

                service_registration "kubernetes" {}

                seal "awskms" {
                  region     = "${AWS::Region}"
                  kms_key_id = "${VaultKmsKey}"
                }
      - SomeValue: "test"
  VaultClusterRole:
    Type: "AWSQS::Kubernetes::Resource"
    Properties:
      ClusterName: !Ref ClusterName
      Namespace: !Ref KubernetesNameSpace
      Manifest: !Sub
      - |
        apiVersion: rbac.authorization.k8s.io/v1
        kind: ClusterRole
        metadata:
          labels:
            app.kubernetes.io/name: ${ResourceName}
          name: ${ResourceName}
        # Modify for your scripts here
        rules:
        - apiGroups:
          - ""
          resources:
          - pods/exec
          - pods
          - pods/log
          verbs:
          - get
          - list
          - create 
      - ResourceName: booter-vault
        NameSpace: !Ref KubernetesNameSpace
        S3ScriptURL: !Ref BootStrapScriptS3URI
        RoleName: !Sub "VaultIAMRole-${PsuedoRandom.GroupId}"
  VaultServiceAccount:
    Type: "AWSQS::Kubernetes::Resource"
    Properties:
      ClusterName: !Ref ClusterName
      Namespace: !Ref KubernetesNameSpace
      Manifest: !Sub
      - |
        apiVersion: v1
        kind: ServiceAccount
        metadata:
          labels:
            app.kubernetes.io/name: ${ResourceName}
          annotations:
            eks.amazonaws.com/role-arn: arn:aws:iam::${AWS::AccountId}:role/${RoleName}
          name: ${ResourceName}
          namespace: ${NameSpace}
      - ResourceName: booter-vault
        NameSpace: !Ref KubernetesNameSpace
        S3ScriptURL: !Ref BootStrapScriptS3URI
        RoleName: !Sub "VaultIAMRole-${PsuedoRandom.GroupId}"
  VaultInitialisationJob:
    Type: "AWSQS::Kubernetes::Resource"
    Properties:
      ClusterName: !Ref ClusterName
      Namespace: !Ref KubernetesNameSpace
      Manifest: !Sub
      - |
        apiVersion: batch/v1
        kind: Job
        metadata:
          name: ${ResourceName}
          namespace: ${NameSpace}
        spec:
          template:
            spec:
              containers:
              - name: ${ResourceName}
                image: amazonlinux
                command: ["/bin/bash","-c"]
                args:
                - >
                  sleep 15;
                  yum install -y awscli;
                  export AWS_REGION=${AWS::Region};
                  aws sts get-caller-identity;
                  aws s3 cp ${!S3_SCRIPT_URL} ./script.sh &&
                  chmod +x ./script.sh &&
                  ./script.sh
                env:
                - name: S3_SCRIPT_URL
                  value: ${S3ScriptURL}
                - name: VAULT_SECRET
                  value: ${VaultSecret}
                - name: AWS_REGION
                  value: ${AWS::Region}
              serviceAccountName: ${ResourceName}
              restartPolicy: Never
          backoffLimit: 4
      - ResourceName: booter-vault
        NameSpace: !Ref KubernetesNameSpace
        S3ScriptURL: !Ref BootStrapScriptS3URI
        RoleName: !Sub "VaultIAMRole-${PsuedoRandom.GroupId}"
  VaultClusterRoleBinding:
    Type: "AWSQS::Kubernetes::Resource"
    Properties:
      ClusterName: !Ref ClusterName
      Manifest: !Sub
      - |
        apiVersion: rbac.authorization.k8s.io/v1
        kind: ClusterRoleBinding
        metadata:
          labels:
            app.kubernetes.io/name: ${ResourceName}
          name: ${ResourceName}
        roleRef:
          apiGroup: rbac.authorization.k8s.io
          kind: ClusterRole
          name: ${ResourceName}
        subjects:
        - kind: ServiceAccount
          name: ${ResourceName}
          namespace: ${NameSpace}
      - ResourceName: booter-vault
        NameSpace: !Ref KubernetesNameSpace
        S3ScriptURL: !Ref BootStrapScriptS3URI
        RoleName: !Sub "VaultIAMRole-${PsuedoRandom.GroupId}"
#Outputs:
#  HashicorpVaultReleaseName:
#    Value: !Ref HashicorpVaultHelmChart


